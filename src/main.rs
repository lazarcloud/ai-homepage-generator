use axum::{extract::State, response::Html, routing::get, Router};
use dotenvy::dotenv;
use html_escape;
use rand::{rng, seq::SliceRandom};
use std::{env, net::SocketAddr, sync::Arc};
use tokio::sync::Mutex;
use once_cell::sync::Lazy;
use regex::Regex;

use groq_api_rust::{
    AsyncGroqClient, ChatCompletionMessage, ChatCompletionRequest, ChatCompletionRoles,
};

#[derive(Clone)]
struct AppState {
    client: Arc<Mutex<AsyncGroqClient>>,
}

const CANDIDATE_MODELS: &[&str] = &[
    "gemma2-9b-it",
    "qwen/qwen3-32b",
    "deepseek-r1-distill-llama-70b",
    "llama-3.3-70b-versatile",
    "llama-3.1-8b-instant",
    "openai/gpt-oss-120b",
    "openai/gpt-oss-20b",
];

#[tokio::main]
async fn main() {
    dotenv().ok();

    let api_key = env::var("GROQ_API_KEY").expect("GROQ_API_KEY must be set in .env");
    let client = AsyncGroqClient::new(api_key, None).await;

    let state = AppState {
        client: Arc::new(Mutex::new(client)),
    };

    let app = Router::new()
        .route("/", get(index))
        .with_state(state);

    let addr = SocketAddr::from(([0, 0, 0, 0], 8080));
    println!("Server running at http://{addr}");
    let listener = tokio::net::TcpListener::bind("0.0.0.0:8080").await.unwrap();

    axum::serve(listener, app).await.unwrap();
}

async fn index(State(state): State<AppState>) -> Html<String> {
    let mut models = CANDIDATE_MODELS.to_vec();
    models.shuffle(&mut rng());

    let mut last_error: Option<String> = None;

    for model in models {
        let prompt = format!(r#"You are to generate a COMPLETE, self-contained HTML5 landing page.
Return ONLY raw HTML (no Markdown, no code fences), starting with <!doctype html>, and MUST end with </html>.

Hard limits:
- Keep the entire HTML (including inline CSS+JS) under ~12 KB of text.
- No external JS frameworks and no images. You may include ONE Google Fonts <link> if desired.

Content & style:
- <title>: "AI Web Demo".
- You might include current date and time
- Include <meta charset="utf-8"> and <meta name="viewport" content="width=device-width, initial-scale=1">.
- Unique aesthetic, You MUST include css to style your creation in an unique way. All CSS must be inlined in the same HTML, no external files are allowed
- Hero: big headline + short paragraph explaining the page was generated at request time by AI, and it won't be the same twice.
- Some dynamic feature using javascript
- Footer: include the current year and:
   Generated by {model}
   This project is created by lazar â€” https://bylazar.com"
   Link to this project's GitHub: https://github.com/lazarcloud/ai-based-website
- Make all content visible with proper contrast.

Deliver polished, modern, whimsical vibes. Keep the HTML readable with clear section comments."#);


        let messages = vec![ChatCompletionMessage {
            role: ChatCompletionRoles::User,
            content: prompt,
            name: None,
        }];

        let mut req = ChatCompletionRequest::new(model, messages);
        req.max_tokens = Some(10000);
        req.temperature = Some(0.7);

        let client = state.client.lock().await;

        match client.chat_completion(req).await {
            Ok(resp) => {
                let raw_html = resp
                    .choices
                    .get(0)
                    .map(|c| c.message.content.clone())
                    .unwrap_or_else(|| {
                        format!(
                            "<!doctype html><html><body><h1>No content</h1><p>Model used: {}</p></body></html>",
                            model
                        )
                    });

                let html = strip_think_tags(&raw_html);

                println!("\n===== [{}] SUCCESS =====\n{}\n", model, html);

                return Html(html);
            }
            Err(err) => {
                last_error = Some(format!("{model} failed: {err}"));
            }
        }
    }

    let err_str = last_error.unwrap_or_else(|| "No models succeeded".to_string());
    let safe = html_escape::encode_text(&err_str);
    Html(format!(
        r#"<!doctype html>
<html>
  <head><meta charset="utf-8"><title>Error</title></head>
  <body>
    <h1>Oops!</h1>
    <p>Failed to generate HTML with all candidate models.</p>
    <pre style="white-space:pre-wrap">{}</pre>
  </body>
</html>"#,
        safe
    ))
}

static THINK_RE: Lazy<Regex> = Lazy::new(|| {
    Regex::new(r"(?is)<\s*think\s*>.*?<\s*/\s*think\s*>").expect("valid regex")
});

static FENCE_RE: Lazy<Regex> = Lazy::new(|| {
    Regex::new(r"(?is)```(?:html)?\s*(.*?)\s*```").expect("valid regex")
});

fn strip_think_tags(s: &str) -> String {
    let no_think = THINK_RE.replace_all(s, "").to_string();
    if let Some(caps) = FENCE_RE.captures(&no_think) {
        caps.get(1).map(|m| m.as_str().to_string()).unwrap_or(no_think)
    } else {
        no_think
    }
}