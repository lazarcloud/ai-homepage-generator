use crate::clients::groq::GroqClient;
use crate::error::{Result, AppError};
use groq_api_rust::{ChatCompletionMessage, ChatCompletionRequest, ChatCompletionRoles};
use once_cell::sync::Lazy;
use rand::{rng, seq::SliceRandom};
use regex::Regex;
use time::OffsetDateTime;

static THINK_RE: Lazy<Regex> =
    Lazy::new(|| Regex::new(r"(?is)<\s*think\s*>.*?<\s*/\s*think\s*>").unwrap());
static FENCE_RE: Lazy<Regex> =
    Lazy::new(|| Regex::new(r"(?is)```(?:html)?\s*(.*?)\s*```").unwrap());

const CANDIDATE_MODELS: &[&str] = &[
    "gemma2-9b-it",
    "qwen/qwen3-32b",
    "deepseek-r1-distill-llama-70b",
    "llama-3.3-70b-versatile",
    "llama-3.1-8b-instant",
    "openai/gpt-oss-120b",
    "openai/gpt-oss-20b",
];

pub async fn generate_page(groq: &GroqClient) -> Result<(String, String)> {
    let mut models = CANDIDATE_MODELS.to_vec();
    models.shuffle(&mut rng());

    let now_str = OffsetDateTime::now_utc()
        .format(&time::format_description::well_known::Rfc3339)
        .unwrap();

    for model in models {
        let prompt = format!(r#"You are to generate a COMPLETE, self-contained HTML5 landing page.
Return ONLY raw HTML (no Markdown, no code fences), starting with <!doctype html>, and MUST end with </html>.

Hard limits:
- Keep the entire HTML (including inline CSS+JS) under ~12 KB of text.
- No external JS frameworks and no images. You may include ONE Google Fonts <link> if desired.

Content & style:
- <title>: "AI Web Demo".
- You might include current date and time (now: {now_str})
- Include <meta charset="utf-8"> and <meta name="viewport" content="width=device-width, initial-scale=1">.
- Unique aesthetic with inlined CSS only.
- Hero: big headline + short paragraph explaining the page was generated at request time by AI, and it won't be the same twice.
- Some dynamic feature using javascript.
- Footer: include the current year and:
   Generated by {model}
   This project is created by lazar â€” https://bylazar.com
   Link to this project's GitHub: https://github.com/lazarcloud/ai-based-website
- Make all content visible with proper contrast.

Deliver polished, modern, whimsical vibes. Keep the HTML readable with clear section comments."#);

        let req = {
            let messages = vec![ChatCompletionMessage {
                role: ChatCompletionRoles::User, content: prompt, name: None
            }];
            let mut r = ChatCompletionRequest::new(model, messages);
            r.max_tokens = Some(4000);
            r.temperature = Some(0.85);
            r
        };

        match groq.0.chat_completion(req).await {
            Ok(resp) => {
                let raw = resp.choices.get(0)
                    .map(|c| c.message.content.clone())
                    .unwrap_or_else(|| format!("<!doctype html><html><body><h1>No content</h1><p>{model}</p></body></html>"));
                return Ok((strip_think_tags(&raw), model.to_string()));
            }
            Err(e) => {
                tracing::warn!(%model, error=?e, "model failed, trying next");
            }
        }
    }
    Err(AppError::Generation("all models failed".into()))
}

fn strip_think_tags(s: &str) -> String {
    let no_think = THINK_RE.replace_all(s, "").to_string();
    if let Some(caps) = FENCE_RE.captures(&no_think) {
        caps.get(1).map(|m| m.as_str().to_string()).unwrap_or(no_think)
    } else { no_think }
}
